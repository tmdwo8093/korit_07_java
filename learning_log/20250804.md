# Setter / Getter

## 1. Setter / Getter의 필요성

### 문제 상황

- Person 클래스 생성한다고 가정하면

-> 이름, 나이 등의 정보를 저장하기 위해서 필드를 선언합니다.

```java
public class Person {
    String name;
    int age;
}
// 그리고 이를 PersonMain에서 객체를 만든다고 가정
public class PersonMain {
    public static void main(String[] args) {
        // Person 객체 생성
        Person person1 = new Person();
        
        // 속성에 값 대입
        person1.name = "강수림";
        person1.age = -10;
        
    }
}
```

이상의 코드를 확인했을 때 나이에 정상적이지 않은 값이 대입되었습니다.
이처럼 외부에서 직접 속성값을 대입하게 될 때, 이상한 값이 들어가더라도 통제할 수 있는 방법이 없다는 문데가 있습니다.

-> 이를 해결하기 위한 방법이 바로!!
- `Setter / Getter`

## 2. Setter / Getter란?

### Setter

- 데이터를 '설정'하는 역할의 'method'. 클래스 외부에서 필드를 직접 수정하지 못하도록 막고,
  특정 메서드를 통해 안전하게 값을 반환하도록 함.

### Getter

- 데이터를 '조회'하는 역할의 'method'. 클래스 외부에서 필드를 직접 읽지 못하도록 막고,
  특정 메서드를 통해 안전하게 값을 반환하도록 함.

## 3. 장점

1. 데이터 보호
    - 변수가 private 접근 제어자를 사용하여 외부에서 직접 접근하지 못하게 함으로써 데이터를 보호할 수 있음.

2. 데이터의 유효성 검증
    -  Setter 메서드에서 입력된 데이터가 적합한지 확인하고, 잘못된 값을 가부할 수 있음.

3. 캡슐화(Encapsulation)
    - 데이터를 숨기고 필요한 경우에만 제한적으로 접근할 수 있게 하여 클래스 내부 구현을 외부에 노출하지 않음

4. 유연성 증가
    - 나중에 요구 사항이 바뀌어 데이터를 설정하거나 조회하는 방법이 변경되더라도 클래스 내부의 메서드만 수정하면 되므로 유지 보수가 쉬워짐

## 4. Setter / Getter가 언제나 필수적인가?

모든 경우에 Setter / Getter가 필요한 것은 아니지만,

일정 사이즈 이상의 프로젝트를 진행하며 다수의 데이터를 입력 받을 경우

적절한 데이터임을 검증하는 과정을 명시하기 위해서는 Setter / Getter를 사용하는 것이 효과적이다.



## UnivStudent 예제

```java
package ch10_setter_getter.univ_student;

public class UnivStudent {
    private String name;
    private int grade;
    private double score;

    public UnivStudent() {
    }

    public UnivStudent(String name) {
        this.name = name;
    }

    public UnivStudent(int grade) {
        if (grade < 1 || grade > 4){
            System.out.println("올바르지 않은 grade 입력입니다.\n");
            return;
        }
        this.grade = grade;
    }

    public UnivStudent(String name, int grade) {
        this.name = name;

        if (grade < 1 || grade > 4){
            System.out.println("올바르지 않은 grade 입력입니다.\n");
            return;
        }
        this.grade = grade;
    }

    public UnivStudent(String name, int grade, double score) {
        this.name = name;

        // grade
        if (grade < 1 || grade > 4){
            System.out.println("올바르지 않은 grade 입력입니다.\n");
            return;
        }
        this.grade = grade;

        // score
        if (score < 0.0 || score > 4.5){
            System.out.println("올바르지 않은 score 입력입니다.\n");
            return;
        }
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getGrade() {
        return grade;
    }

    public void setGrade(int grade) {
        if (grade < 1 || grade > 4){
            System.out.println("올바르지 않은 grade 입력입니다.\n");
            return;
        }
        this.grade = grade;
    }

    public double getScore() {
        return score;
    }

    public void setScore(double score) {
        if (score < 0.0 || score > 4.5){
            System.out.println("올바르지 않은 score 입력입니다.\n");
            return;
        }
        this.score = score;
    }

    void showInfo() {
        System.out.println("이름 : " + name);
        System.out.println("학년 : " + grade);
        System.out.println("점수 : " + score);
        System.out.println();
    }
}


package ch10_setter_getter.univ_student;

public class UnivStudentMain {
    public static void main(String[] args) {
        UnivStudent student1 = new UnivStudent();
        student1.setName("김일");
        student1.setGrade(1);
        student1.setScore(3.3);

        UnivStudent student2 = new UnivStudent("김이");
        student2.setGrade(3);
        student2.setScore(-30);
        student2.setScore(4.0);

        UnivStudent student3 = new UnivStudent(5);
        student3.setName("김삼");
        student3.setGrade(2);
        student3.setScore(2.7);

        UnivStudent student4 = new UnivStudent("김사", 4);
        student4.setScore(3.8);

        UnivStudent student5 = new UnivStudent("김오", 2, 1.0);

        // showInfo
        student1.showInfo();
        student2.showInfo();
        student3.showInfo();
        student4.showInfo();
        student5.showInfo();
    }
}

```

### 결과

```java
올바르지 않은 score 입력입니다. //  student2 -> 기본 생성자 김이 / 3 / -30 -> 실패 4.0

올바르지 않은 grade 입력입니다. //  student3 -> 기본 생성자 김삼 / 5 -> 실패 2 / 2.7

이름 : 김일
학년 : 1
점수 : 3.3

이름 : 김이
학년 : 3
점수 : 4.0

이름 : 김삼
학년 : 2
점수 : 2.7

이름 : 김사
학년 : 4
점수 : 3.8

이름 : 김오
학년 : 2
점수 : 1.0
```

## 1. 정의

클래스, 변수, 메서드의 접근 범위를 제어하는 키워드.



### ✨ 접근 지정자를 사용하는 이유

정보 은닉 (Encapsulation)

보안성 향상 (데이터 보호)

코드 유지보수성 향상 (캡슐화를 통한 결합도 감소)

---

## 2. 접근 지정자의 종류

### 🔹 public

어디서든 접근 가능 (같은 클래스, 같은 패키지, 다른 패키지 모두 접근 가능)

자동 생성되는 setter/getter는 기본적으로 public

### 🔹 protected

같은 패키지 내의 클래스 또는 해당 클래스를 상속받은 자식 클래스에서 접근 가능

외부 패키지에서도 상속을 받으면 접근 가능

### 🔹 default (아무 접근 지정자 없음)

같은 패키지 내에서만 접근 가능

패키지가 다르면 접근 불가능

### 🔹 private

같은 클래스 내부에서만 접근 가능

외부 클래스에서는 접근 불가능 → getter/setter를 이용해 접근해야 함

---

## 3. 예제 코드

✅ 접근 지정자 예제 (AccessModifierExample.java)

```java
package ch11_access_modifier;

class AccessModifierExample {
    // 필드 선언
    public int publicVar = 10;
    protected int protectedVar = 20;
    int defaultVar = 30;
    private int privateVar = 40;

    // 메서드 선언
    public void show() {
        System.out.println("public : " + publicVar);
        System.out.println("protected : " + protectedVar);
        System.out.println("default : " + defaultVar);
        System.out.println("private : " + privateVar);
    }
}

public class Main {
    public static void main(String[] args) {
        // 객체 생성

        AccessModifierExample accessModifierExample = new AccessModifierExample();

        System.out.println(accessModifierExample.publicVar);
        System.out.println(accessModifierExample.protectedVar);
        System.out.println(accessModifierExample.defaultVar);
//        System.out.println(accessModifierExample.privateVar);

        accessModifierExample.show();
    }
}

```

✅ private 속성 접근 예제 (Person.java)

```java
package ch11_access_modifier;

class Person {
    private String name;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    void show() {
        System.out.println("Pr");
    }
}

public class PersonMain {
    public static void main(String[] args) {
        Person person1 = new Person();

        person1.setName("김일");

        System.out.println(person1.getName());

        person1.setName("김이");

        System.out.println(person1.getName());
    }
}
```

---

## 4. 같은 .java 파일 내의 클래스 관계 🧐

하나의 `.java` 파일에 두 개의 클래스가 작성되어 있을 때,
이 두 클래스의 관계는 같은 패키지 안에 작성된 두 개의 `.java` 파일과 동일한 관계라고 볼 수 있다.

### ✅ 이유

- 동일한 .java 파일에 있더라도, 클래스는 같은 패키지 내부에서 정의된 것으로 간주됨

- 접근 지정자(public, protected, default, private)의 적용 범위는 패키지를 기준으로 판단됨

- 단, 하나의 .java 파일에서 public 클래스를 두 개 이상 정의할 수 없음

---

### ✅ 예제 (위의 AccessModifierExample.java와 Person.java)

📌 결론: 같은 `.java` 파일에 있는 클래스들은 동일한 패키지 내의 클래스들과 동일한 접근 관계를 가진다.

---

## 5. 정리 📝

✅ `public` → 어디서든 접근 가능

✅ `protected` → 같은 패키지 & 상속 관계에서 접근 가능

✅ `default` → 같은 패키지 내에서만 접근 가능

✅ `private` → 같은 클래스 내에서만 접근 가능

▶ **접근 지정자는 보안성과 유지보수성을 고려하여 적절히 활용해야 한다!** )

📌 결론: 같은 .java 파일에 있는 클래스들은 동일한 패키지 내의 클래스들과 동일한 접근 관계를 가진다.









