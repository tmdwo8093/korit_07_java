# 추상 클래스 (Abstract Class)

## 📌추상 클래스란?
- `추상 메서드`: 선언만 있고, 구현은 없는 메서드.
- `추상 클래스`: 추상 메서드가 하나 이상 정의되어 있는 클래스.

### 🔹추상 클래스
1. 추상 메서드가 하나라도 포함되면 해당 클래스는 추상 클래스로 정의되어야 함.
2. 추상 클래스는 객체를 생성할 수 없음. -> 일반 클래스와의 차이
3. 그 외 다른 특징은 일반 클래스와 동일함
4. 상속을 전제로 하는 클래스.

```java
// 일반 메서드
public void showInfo() {
    System.out.println("제 이름은 " + name + "입니다.");
}

// 추상 메서드
public void showName();
```

### 🔹추상 클래스의 장점
- 코드의 재사용성을 높이고 설계를 보다 명확하게 할 수 있도록 도와준다.

### 🔹추상 클래스의 목적
1. 공통된 기능 제공: 여러 클래스에서 공통적으로 사용하는 기능을 추상 클래스에서 정의.

2. 구체적인 구현 강제 : 추상 메서드를 통해 자식 클래스가 반드시 특정 메서드를 구현하도록 강제할 수 있음.

3. 코드의 재사용성: 중복되는 코드를 줄이고, 유지 보수성을 향상.

### 💡주의 사항
- 추상 클래스는 객체를 생성할 수 없다.

### 💡super 키워드
- `super(매개변수)` → 자식 클래스에서 부모 클래스의 생성자를 호출할 때 사용.

- `super.메서드명()` → 자식 클래스에서 부모 클래스의 메서드를 호출할 때 사용.

## 📌예제
### 1. Factory (추상 클래스)
```java
package ch14_abstraction.abstract_class;

public abstract class Factory {
    private String name;

    public Factory(String name) {
        this.name = name;
    }

    // 메서드 정의
    public abstract void produce(String model);
    public abstract void manage();
    // 팝업을 확인하고 고침
    // 기존
    // public class Factory {
    //      public void produce();
    // }


    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void displayInfo() {
        System.out.println("공장의 정보를 출력합니다.\n" +
                "공장 이름 : " + name);
    }
}
```
### 2. PhoneFactory (상속받은 클래스)
```java
package ch14_abstraction.abstract_class;

public class PhoneFactory extends Factory {

    // 생성자 및 메서드
    public PhoneFactory(String name) {
        super(name);
    }

    @Override
    public void produce(String model) {
        System.out.println("[ " + model + " ] 모델 스마트폰을 생성합니다." );
    }

    @Override
    public void manage() {
        System.out.println("스마트폰 공장을 관리합니다.");
    }
}
```
### 3. TableFactory (상속받은 클래스)
```java
package ch14_abstraction.abstract_class;

public class TableFactory extends Factory {
    public TableFactory(String name) {
        super(name);
    }

    @Override
    public void produce(String model) {
        System.out.println("[ " + model + " ] 모델 스마트폰을 생성합니다." );
    }

    @Override
    public void manage() {
        System.out.println("가구 공장을 관리합니다.");
    }
}
```
### 4. Main (main)
```java
package ch14_abstraction.abstract_class;

public class Main {
    public static void main(String[] args) {
        // 추상 클래스는 객체를 생성할 수 없다
        Factory factory1 = new Factory("가전 제품 공장") {
            @Override
            public void produce(String model) {
                System.out.println(this.getName() + "에서 [ " + model + " ]을 생산합니다.");
            }

            @Override
            public void manage() {
                System.out.println("가전 제품 공장을 관리합니다.");
            }
        };      // 특이 케이스, 메서드를 정의 X -> 객체 생성 O

        factory1.displayInfo();
        factory1.produce("백색 가전 냉장고");
        // 재사용하지 않고 한 번만 쓰고 말 예정이라면(즉 이 Main 클래스에서만 쓸 거라면), 사용하기 좋습니다.


        PhoneFactory phoneFactory1 = new PhoneFactory("애플 스마트폰 공장");
        System.out.println();

        // 부모 클래스에서 선언한 추상 클래스를 자식 클래스에서 구현부 작성한거 확인
        phoneFactory1.produce("아이폰17");
        phoneFactory1.manage();
        System.out.println();

        phoneFactory1.setName("삼성 스마트폰 공장");    // Factory 에서 override 하지 않은 메서드 호출
        phoneFactory1.displayInfo();

        // 즉, 오버라이딩은 `재정의`를 전제로 부모 클래스와 자식 클래스의 메서드가
        // 서로 다른 방식으로 동작하는 경우에만 이루어지면 되고,
        // 부모 클래스의 메서드를 완전히 동일하게 자식 클래스에서 사용할 경우에는
        // 굳이 alt + insert 를 통해서 `재정의`하여 오버라이딩 할 필요가 없다.
    }
}
```

### 🔹결과
```java
공장의 정보를 출력합니다.
공장 이름 : 가전 제품 공장
가전 제품 공장에서 [ 백색 가전 냉장고 ]을 생산합니다.

[ 아이폰17 ] 모델 스마트폰을 생성합니다.
스마트폰 공장을 관리합니다.

공장의 정보를 출력합니다.
공장 이름 : 삼성 스마트폰 공장
```

## 📝정리

- **추상 클래스**는 추상 메서드가 하나 이상 포함된 클래스로, 직접 객체를 생성할 수 없으며 반드시 상속을 통해 사용된다. 추상 메서드는 선언만 있고 구현은 자식 클래스에서 정의해야 한다.

- 추상 클래스의 주요 목적은:
    1. **공통된 기능 제공**: 여러 클래스에서 공통적으로 사용하는 기능을 추상 클래스에서 정의하여 코드 중복을 줄인다.
    2. **구체적인 구현 강제**: 추상 메서드를 통해 자식 클래스가 반드시 특정 메서드를 구현하도록 강제한다.
    3. **코드의 재사용성**: 중복되는 코드를 줄이고, 유지 보수성을 높여준다.

- **super 키워드**를 활용하여 자식 클래스에서 부모 클래스의 멤버와 메서드에 접근할 수 있다.

- **Factory 클래스**는 추상 클래스로, `produce()`와 `manage()` 메서드를 자식 클래스에서 구현하도록 강제하며, 이를 통해 다양한 종류의 공장 클래스를 만들 수 있다.

- `PhoneFactory`와 `TableFactory` 클래스는 `Factory` 클래스를 상속받아 각기 다른 방식으로 `produce()`와 `manage()` 메서드를 구현한다.

- **추상 클래스**는 설계를 명확하게 하고, 코드의 재사용성과 유지 보수성을 높이는 데 유용하다. 상속을 통한 구체적인 구현을 강제함으로써, 자식 클래스는 공통된 기능을 공유하면서도 자신만의 특화된 기능을 구현할 수 있다.


# 인터페이스 (Interface)
Java 에서 클래스가 구현해야하는 메서드들의 집합을 정의하는 규약(protocol)

인터페이스는 메서드의 시그니처만(메서드 이름, 리턴 타입 매개변수 목록)을 포함하며,

메서드의 실제 구현은 포함하지 않음

-> 추상 메서드만 있음

- 다중 상속 지원

-> 이를 통해 클래스가 여러 인터페이스를 구현할 수 있음

 - 추상 클래스는 단일 상속을 지원해서 상속 과정을 알아보기 쉽다고 작성했는데,
 - 인터페이스는 다중 상속을 지원해서 편하다고 이야기를 합니다.

## 특징
1. 추상 메서드 : 인터페이스 내의 모든 메서드 들은 기본적으로 추상 메서드
    - 추상 클래스는 일반 메서드도 있었지만, 인터페이스는 강제적으로 추상 메서드 입니다.
2. 상수 : 인터페이스 내에서 선언된 모든 변수는 자동으로 public static final 상수로 취급
3. 다중 상속 : 클래스는 여러 인터페이스를 구현(implement)할 수 있음.

## 인터페이스와 추상 클래스의 공통점
- 모두 추상 메서드를 포함할 수 있고, 이를 서브 클래스에서 구현해야한다.

## 인터페이스와 추상 클래스의 차이점
### - 추상 클래스
1. 부분 구현 허용 : 추상 클래스는 추상 메서드 뿐만 아니라 일반 메서드 포함 가능
2. 상태 저장 가능 : 추상 클래스는 field를 가질 수 있다.
3. 단일 상속 : (일반) 클래스는 하나의 추상 클래스만 상속받을 수 있다.
4. 생성자 : 추상 클래스는 생성자를 가질 수 있다.
``` java
 // 어떤 추상 클래스
 public abstract class Person {
    // 필드 선언
    private String name;
    // AllArgsConstructor
    public Person(String name) {
       this.name = name;
   }
   // method 구현
   public abstract introduce();
    }
    
    // 위의 추상 클래스를 상속받는 일반 클래스
    public class Student extends Person {
        // 서브 클래스의 필드 선언
        private String school;
        // 추상 클래스가 AllArgsConstructor 생성자만 가지고 있기 때문에
        // Student 클래스가 객체를 생성 할 수 있는 경우의 수는 이렇게 두 가지만 존재하게 됩니다
        public Student(String name) {
            super(name);
        }
        public Student(String name , String school) {
            super(name);
            this school = school;
        }
```
이상의 코드라인으로 알 수 있는것은, 객체 생성을 직접적으로 하지 못하는 추상 클래스의 생성자
의 유무로 인해 자식 클래스의 생성자 정의 방식(객체 생성 방식)을 통제할 수 있다는 점입니다.

그래서 특정 서브 클래스의 객체 생성 방식을 강제하고 싶을 때 사용하는것이 추상 클래스의 생성자
라고 생각하시면 되겠습니다.

5. 다양한 접근 지정자(Access Modifier) : 추상 클래스의 메서드와 변수는 다양한 접근 지정자를 가질 수 있다.

### - 인터페이스
1. 완전한 추상화 : 모든 메서드가 추상 메서드
   (Java8 이후에 default / static 메서드 사용 가능함)
2. 인터페이스는 인스턴스 변수(필드 중 객체마다 값이 다른 변수를 의미함)를 가질 수 없고, 상수만 선언 가능(final 키워드)
3. 다중 상속 : 클래스는 여러 인터페이스를 `구현할 수 있다`.(상속과 용어를 구분 짓는 편)
4. 생성자 없음 : 인터페이스는 생성자(객체를 생성할 때 호출되는 특별한 `메서드`)를 가질 수 없다.
   -> 일단 필드에서 객체 마다 다른 값을 지닐 수 없기 때문에 생성자 정의 불가능
5. 자동 public : 인터페이스의 메서드는 자동 public이며, 메서드 선언에 접근 지정자를 명시할 필요가 없다.
   그러나 (Java8 이후에 default / static 메서드가 존재함)

```java
package ch14_abstraction.interfaces;

public class TvRemoteController {
    // [ 클래스명 객체명 ] 을 이용한 필드 선언 (ex. String str 등)
    private PowerButton powerButton;
    private ChannelDownButton channelDownButton;
    private ChannelUpButton channelUpButton;

    public TvRemoteController(PowerButton powerButton, ChannelDownButton channelDownButton, ChannelUpButton channelUpButton) {
        this.powerButton = powerButton;
        this.channelDownButton = channelDownButton;
        this.channelUpButton = channelUpButton;
    }
}

package ch14_abstraction.interfaces;

public class Main {
  public static void main(String[] args) {
    TvRemoteController tvRemoteController = new TvRemoteController();

  }
}
```

_tvRemoteController_ 객체를 생성하기 위한 _argument_ 는 무엇을 사용해야할까?

```java
String hello1 = "안녕하세요";
String hello2 = new String("안녕하세요");
```
_String_ 의 경우 _class_ 라는 것을 알 수 있다.
그래서 사실 hello1 / hello2는 변수명이 아니라 객체명이었다.

```java
String name = "백승재";
Student student = new Student(name, "기계공학과");
```
에서도 마찬가지로 '백승재', '기계공학과'는 객체라는 것 또한 알 수 있고

객체를 생성할 때 생성자의 argument 로 객체로 받을 수 있다는 것 또한 유추할 수 있다.

객체가 있기는 하지만 객체명이 없을 수 있다.

```java
        //우리가 지금까지 해온 방식

        PowerButton powerButton1 = new PowerButton();
        ChannelDownButton channelDownButton1 = new ChannelDownButton();
        ChannelUpButton channelUpButton1 = new ChannelUpButton();

        TvRemoteController tvRemoteController1 = new TvRemoteController(powerButton1, channelDownButton1, channelUpButton1);

        powerButton1.onPressed();
        powerButton1.onPressed();
        System.out.println();

        channelDownButton1.onDown();
        channelDownButton1.onPressed();
        System.out.println();

        System.out.println(channelUpButton1.onUp());
        channelUpButton1.onPressed();
        System.out.println();
        
        // 다시 배우는 방식
        // TvRemoteController 클래스에서 각 기능들을 정의 및 호출
        TvRemoteController tvRemoteController = new TvRemoteController(new PowerButton(), new ChannelDownButton(), new ChannelUpButton());

        tvRemoteController.onPressedPowerButton();
        tvRemoteController.onPressedPowerButton();
        System.out.println();

        tvRemoteController.onPressedChannelDownButton();
        tvRemoteController.onDownChannelDownButton();
        System.out.println();

        tvRemoteController.onPressedChannelUpButton();
        System.out.println(tvRemoteController.onUpChannelUpButton());

```

1. 서브 클래스(VolumeDownButton) 생성
2. 상속 받기 (extends Button)
3. 추상 메서드 구현 (onPressed())
4. 필요한 메서드 오버라이드 (onDown())
5. field 에 VolumeDownButton volumeDownButton 추가 (alt + ins)
6. TvRemoteController에
```java
  public void onPressedVolumeDownButton() {
      volumeDownButton.onPressed();
  }

  public void onDownVolumeDownButton() {
      volumeDownButton.onDown();
  }
```
추가

7. main에서 test
```java
package ch14_abstraction.interfaces;

public class Main {
    public static void main(String[] args) {
        // TvRemoteController 클래스에서 각 기능들을 정의 및 호출
        TvRemoteController tvRemoteController = new TvRemoteController
                (new PowerButton(), new ChannelDownButton(), new ChannelUpButton(), // 첫 실습에서 만든 argument
                        new VolumeDownButton());  // 두 번째 실습에서 추가한 argument

        // 첫 실습
        tvRemoteController.onPressedPowerButton();
        tvRemoteController.onPressedPowerButton();
        System.out.println();

        tvRemoteController.onPressedChannelDownButton();
        tvRemoteController.onDownChannelDownButton();
        System.out.println();

        tvRemoteController.onPressedChannelUpButton();
        tvRemoteController.onUpChannelUpButtonBySout();   // void
        System.out.println(tvRemoteController.onUpChannelUpButtonByString());   // return String
        System.out.println();

        // 두 번째 실습
        tvRemoteController.onPressedVolumeDownButton();
        tvRemoteController.onDownVolumeDownButton();
        System.out.println();
    }
}

```
결과
```java
전원을 켭니다.
전원을 끕니다.

채널을 한 칸 내립니다.
채널을 계속 내립니다.

채널을 한 칸 올립니다.
채널을 계속 올립니다.
채널을 계속 올립니다.

음량을 계속 내립니다.
음량을 한 칸 내립니다.
```

용어 정리
1. 추상 메서드
2. 추상 클래스
3. 인터페이스
4. 단일 상속
5. 다중 상속
6. 추상 클래스 vs. 인터페이스 공통점, 차이점
7. 클래스의 필드에 객체가 들어갈 수 있다

   그로 인한 Main 단계에서 객체 생성 방식에 어떤 차이가 생기는지.

   그리고 필드에 객체가 들어가 있을 때, 특정 객체의 메서드를 사용하는 방법은 무엇인지.
