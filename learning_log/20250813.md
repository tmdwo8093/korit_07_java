# 제네릭 (Generic)

## 정의
클래스나 메서드가 `다룰 데이터 타입`을 미리 명시하여 재사용성과 유연성을 높이는 기술

## 형태
```java
import lombok.AllArgsConstructor;
@AllArgsConstructor
public class Generic<T> {
    private String name;
    private T genericData;

     public static void main(String[] args) {
        Generic<String> generic1 = new Generic<>("김일", "안녕하세요, 김일입니다.");
        Generic<Integer> generic2 = new Generic<>("김이", 01012341234);
        // 위와 같이 T의 자리에 자료형을 명시하면
        // 해당하는 자료형의 데이터 타입을 사용할 수 있다.
    }
}
```


### 타입 매개변수(Type Parameter)
- 클래스나 메서드에서 사용할 실제 타입을 `대신하여` 사용하는 매개변수
- 일반적으로 알파벳 대문자 하나로 표기함
  1. T(Type) : 일반적으로 클래스 타입을 나타낼 때 사용
  2. E(Element) : 컬렉션의 요소를 나타낼 때 사용
  3. K(Key) : Map 의 key 를 나타낼 때 사용
  4. V(Value) : Map 의 value 또는 제네릭 타입의 반환값으로 사용

### 재사용성
- 제네릭을 사용하면 다양한 자료형에 대해 하나의 클래스나 메서드를 정의할 수 있어 코드의 재사용성을 높이고
중복을 줄인다.


### 타입 안정성(Type Safety)
- 컴파일 시점에 타입 체크를 할 수 있어 프로그램의 안정성을 높이고, 명시적인 형변환을 줄인다.


# Java 제네릭 와일드카드(Generic Wildcard)

## 제네릭
- 클래스, 인터페이서, 메서드에 사용되는 자료형을 매개변수화 할 수 있도록 하는 문법.
- 다양한 타입에 대한 재사용이 가능하다.

```java
class Box<T> {
    // 필드 선언
    private T value;
    public void setValue(T Value){
        this.value = value;
    }
    public T getValue() {return value;}
}
```
이렇게 사용할 때 `Box<Integer>` / `Box<String>` 같은 식으로 value의 자료형을 하나로 고정하지 않고 사용 가능함.

## 와일드카드
- 이상의 제네릭 타입을 사용할 때 구체적인 타입을 명시하지 않고도 범용적으로 처리하고 싶을 때 사용하는 "?" 기호.

```java
import java.util.ArrayList;

public static void main(String[] args) {
  List<?> exampleList = new ArrayList<>();
}
```
즉 `<?>`는 무슨 타입이든 가능하다는 뜻.

### 종류
1. <?> : 모든 타입 허용 (unbounded)
  - 읽기 전용, 어떤 타입이든 받아야 할 때
2. <? extends T> : T 또는 T의 서브 타입 클래스 (자식 클래스)
  - 읽기 전용, 제한된 타입에서 받아야 할 때
3. <? super T> : T 또는 T의 슈퍼 타입 (부모 클래스)
  - 쓰기 전용, 제한된 타입으로 입력할 때


# Animal 클래스의 <? extends T> 예제

## 예제 코드

### `Animal.java`
```java
package ch18_generic.wildcard;

public abstract class Animal {
    public abstract void move();
}
```
### `Human,java` - Animal을 상속하는 클래스
```java
package ch18_generic.wildcard;

public class Human extends Animal{
    @Override
    public void move() {
        System.out.println("사람이 두 발로 걷습니다.");
    }
    
    public void read() {
        System.out.println("사람이 독서합니다.");
    }
}
```
### `Tiger.java` - Animal을 상속하는 클래스
```java
package ch18_generic.wildcard;

public class Tiger extends Animal{
    @Override
    public void move() {
        System.out.println("호랑이가 네 발로 뜁니다.");
    }
    
    public void hunt() {
        System.out.println("호랑이가 사냥합니다.");
    }
}
```
### `Car.java` - Animal을 상속하지 않는 클래스
```java
package ch18_generic.wildcard;

public class Car{
    public void move() {
        System.out.println("차가 움직입니다.");
    }

    public void brake() {
        System.out.println("차가 멈춥니다.");
    }
}
```

### `AnimalData.java`
```java
package ch18_generic.wildcard;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;

@Builder
@Data
@AllArgsConstructor
public class AnimalData<T extends Animal> {
    private T animal;

    // AnimalData 필드인 animal에 Animal 클래스의 상속을 받은
    // Tiger / Human 객체를 필드에 대입

    // 특정 클래스라면 (Animal 상속받은) 객체 정보 출력
    public void printData() {
        ((Animal)animal).move();

        if (animal.getClass() == Human.class) {
            System.out.println(animal.getClass());
            ((Human)animal).read(); // 현재 필드인 animal의 클래스를 조사하여
            // (.getClass()를 통해) 그것이 Human 클래스라면 Human 고유 메서드 실행
        } else if (animal.getClass() == Tiger.class) {
            System.out.println(animal.getClass());
            ((Tiger)animal).hunt();
        } else {

        }
    }
}
```

### `Main.java`
```java
package ch18_generic.wildcard;

public class Main {
    public static void main(String[] args) {
        AnimalData<Tiger> animalData1 = new AnimalData<>(new Tiger());
        AnimalData<Human> animalData2 = new AnimalData<>(new Human());
        AnimalData<Car> animalData3 = new AnimalData<>(new Car());
        // AnimalData로 Car 객체를 생성하려고 하니 오류 발생 들어갔다

        animalData1.printData();
        animalData2.printData();
        animalData3.printData();
        // 물론 .printData() 메서드도 사용 불가
    }
}
```
### 결과
Car의 객체 생성을 주석처리 한 후의 결과 : 
```markdown
호랑이가 네 발로 뜁니다.
class ch18_generic.wildcard.Tiger
호랑이가 사냥합니다.
사람이 두 발로 걷습니다.
class ch18_generic.wildcard.Human
사람이 독서합니다.
```
# 컬렉션 (Collection)

## 정의
- 여러 객체를 모아놓은 것 (배열과의 차이점, 범주가 정해지지 않는다!!)
- 다만 Java에서의 List는 Python에서의 List와도 차이가 있습니다.

## 종류

### 1. List : 순서가 있는 데이터의 집합, 중복 요소 허락.
- ArrayList : 배열 기반의 리스트, 요소(element) 접근 속도가 빠름
- LinkedList : 연결 리스트의 리스트, 삽입 및 삭제 속도가 빠름

### 2. Set : 중복을 허용하지 않는(List와의 차이 #1) 데이터의 집합
- HashSet : 해시 테이블 기반의 집합, 요소(element) 순서 보장 X (List와의 차이 #2)
- TreeSet : 이진(binary) 검색 트리 기반의 집합, 요소가 정렬된 상태로 유지됨

### 3. Map : 키(Key)와 값(Value)의 쌍으로 이루어진 데이터의 집합
- HashMap : 해시 테이블 기반의 맵, 키의 순서 보장 X
- TreeMap : 이진 검색 트리 기반의 맵과 키가 정렬된 상태로 유지

* Java 상에서의 Map의 키(key)=값(value) 쌍을 지칭하는 용어 : Entry
* JS상에서 객체의 키-값 쌍을 지칭하는 용어 : Property(속성)
* 근데 문제는 python에서의 한국어로 속성을 지칭하는 영문 용어 : Attributes

## 📌 Java 컬렉션 프레임워크 정리 (List, Set, Map)

| 컬렉션 유형 | 	기반 구조       |	순서 유지 | 	중복 허용 | 	특징 |
|---|--------------|---|--------|---|
|ArrayList| 	배열 기반       |	✅ 유지| 	✅ 허용	 |배열처럼 인덱스로 접근 가능, 삽입/삭제 속도가 느림|
|LinkedList| 	연결 리스트 기반   |	✅ 유지|	✅ 허용|	삽입/삭제 속도가 빠름, but 검색 속도가 느림|
|HashSet| 	해시 테이블 기반   |	❌ 유지 X|	❌ 불가|	요소의 순서가 없고, 중복을 자동 제거|
|TreeSet| 	 이진 검색 트리 기반  |	✅ 정렬됨|	❌ 불가|	요소가 자동 정렬됨 (오름차순)|
|HashMap| 	해시 테이블 기반   |	❌ 유지 X|	✅ (Value만)|	Key-Value 쌍 저장, Key는 중복 불가|
|TreeMap| 	이진 검색 트리 기반 |	✅ 정렬됨|	✅ (Value만)|	Key를 기준으로 자동 정렬됨|






















